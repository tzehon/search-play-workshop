# ðŸ“˜ String fields

Most data types are queried straightforwardly, and match as one would expect with standard
MongoDB B-Tree indexes. However, `string` fields are exceptional, in many ways. 

There are several ways in which strings can be used:

  * Matching exact values. Good ol' `equals`
  * To search for words, or variations thereof, within a string
  * Partial, or sub-string, matching 
  * For sorting

## `token`

A `token` type mapping indexes strings as-is (or normalized) in a way suitable for full string `equals`
and `in` matching, as well as for `$search.sort`'ing

## `autocomplete`

This field type is paired with an operator by the same name to provide partial, sub-string, matching.

Careful though - while this field type sounds alluring and does match sub-strings, it does not by
itself provide good relevancy or highlighting. 

See also: Relevant As-You-Type Suggestions Search Solution

## `string`

The heart of Lucene - text!  `string` mapped fields are analyzed so that its individual terms are
searchable. 

## Basic examples

lucene.standard matching case-insensitive: https://search-playground.mongodb.com/tools/code-playground/snapshots/664738af4e0a3f240a5de9d9

### Query operators

* `text`: matches any of the query terms; can include synonyms and fuzziness
* `phrase`: matches query terms that occur in proximity
* `regex`: pattern matching
* `wildcard`: matches across missing characters; useful for prefix matching
* `moreLikeThis`: matches documents that overlap important terms

### Analysis occurs on query values

Except on regex and wildcard operators: partial strings not analyzable
Index-time and search-time analyzers can be different, if needed

Remember: itâ€™s a dictionary

Index it how youâ€™d like to find it; search for it how you indexed it

Leverage analyzers to index text efficiently for searching
Index statistics factor into score computations

## Configuration options

  * `storedSource`
  * `synonyms`
