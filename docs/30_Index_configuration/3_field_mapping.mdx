# üëê Field types

Document fields are mapped to a search index based on their BSON data type.

When `dynamic: "true"`, a field is indexed if its field type is supported.

When a field name is explicitly/statically mapped, it will be indexed if the field type also matches the
mapped type.

**TODO**: Turn each of these playgrounds into a challenge

## Basic field types

### boolean
  * `equals`: https://search-playground.mongodb.com/tools/code-playground/snapshots/669e6ab1d49ef6fad98118b4
  * `in`: ...

### date
  * `equals`: ...
  * `in`: ...
  * `near`: ...
  * `range`: https://search-playground.mongodb.com/tools/code-playground/snapshots/669e6b18d49ef6fad98118b6

### number
  * `equals`: 
  * `in`: ...
  * `near`: ...
  * `range`: https://search-playground.mongodb.com/tools/code-playground/snapshots/669e6b4ad49ef6fad98118b8

### ObjectId
  * `equals`: https://search-playground.mongodb.com/tools/code-sandbox/snapshots/678506c2b6487c1cfd0bb540
  * `in`: 

### geo
Dynamic mapping does not support geo-spatial fields, and require a manual/static mapping configuration.

  * `geoWithin`: https://search-playground.mongodb.com/tools/code-playground/snapshots/669e6b762ce7658e786edbfa
  * `geoShape`: 
  * `near`: 

## Other field types

### autocomplete
blah, don‚Äôt do it! ;)
See also: Relevant As-You-Type Suggestions Search Solution

### document

Default dynamic mapping behavior, flattens nested documents into ‚Äúarrays‚Äù of values on main document

### embeddedDocument
Attribute pattern k/v matching, more nuanced than document type flattening
See cool tricks for embedded documents

## string
Basic examples
lucene.standard matching case-insensitive: https://search-playground.mongodb.com/tools/code-playground/snapshots/664738af4e0a3f240a5de9d9

## Analysis matters
‚Äúsearches‚Äù query does not match ‚ÄúSearch‚Äù with lucene.standard: https://search-playground.mongodb.com/tools/code-playground/snapshots/664739964e0a3f240a5de9db
‚Äúsearches‚Äù matches ‚ÄúSearch‚Äù using lucene.english: https://search-playground.mongodb.com/tools/code-playground/snapshots/66473aa64e0a3f240a5de9dd

## Custom analyzers
Last 4 digit of phone number matching (regex extraction during indexing, keyword analysis at query time): https://search-playground.corp.mongodb.com/tools/code-playground/snapshots/669e6c98d49ef6fad98118ba
Example of being able to do ‚ÄòstartsWith‚Äô and ‚ÄòendsWith‚Äô using wildcard and ‚Äòreverse‚Äô token filter:
https://search-playground.mongodb.com/tools/code-playground/snapshots/6683c8bc4a45448733549bbc

Example of being able to do ‚ÄòstartsWith‚Äô, ‚ÄòendsWith‚Äô and ‚Äòcontains‚Äô using nGrams: https://search-playground.mongodb.com/tools/code-playground/snapshots/6683c999934a05d9b585b6e7 
Relevancy
Example of an as-you-type suggest configuration; sophisticated use of multi and several weighted query clauses: https://search-playground.mongodb.com/tools/code-playground/snapshots/66473b744e0a3f240a5de9e1
$project score?
$project scoreDetails?

# multi
Why?
Relevancy example: boost each multi uniquely
Multiple language example: may not know the language of the content and each document could be different - multi across all possible languages, query across them as desired at query-time, let relevancy sort it out
Example of being able to do ‚ÄòstartsWith‚Äô and ‚ÄòendsWith‚Äô using wildcard and ‚Äòreverse‚Äô token filter:
https://search-playground.mongodb.com/tools/code-playground/snapshots/6683c8bc4a45448733549bbc

